<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="cassandra.core">
  <title>Cassandra support</title>

  <para>The Cassandra support contains a wide range of features which are
  summarized below.</para>

  <itemizedlist>
    <listitem>
      <para>Spring configuration support using Java based @Configuration
      classes or an XML namespace for a Cassandra driver instance and replica
      sets</para>
    </listitem>

    <listitem>
      <para>CassandraTemplate helper class that increases productivity
      performing common Cassandra operations. Includes integrated object
      mapping between CQL Tables and POJOs.</para>
    </listitem>

    <listitem>
      <para>Exception translation into Spring's portable Data Access Exception
      hierarchy</para>
    </listitem>

    <listitem>
      <para>Feature Rich Object Mapping integrated with Spring's Conversion
      Service</para>
    </listitem>

    <listitem>
      <para>Annotation based mapping metadata but extensible to support other
      metadata formats</para>
    </listitem>

    <listitem>
      <para>Persistence and mapping lifecycle events</para>
    </listitem>

    <listitem>
      <para>Java based Query, Criteria, and Update DSLs</para>
    </listitem>

    <listitem>
      <para>Automatic implementation of Repository interfaces including
      support for custom finder methods.</para>
    </listitem>
  </itemizedlist>

  <para>For most tasks you will find yourself using <classname>
  CassandraTemplate</classname> or the Repository support that both leverage
  the rich mapping functionality. CassandraTemplate is the place to look for
  accessing functionality such as incrementing counters or ad-hoc CRUD
  operations. CassandraTemplate also provides callback methods so that it is
  easy for you to get a hold of the low level API artifacts such as <literal>
  com.datastax.driver.core.Session</literal> to communicate directly with
  Cassandra. The goal with naming conventions on various API artifacts is to
  copy those in the base DataStax Java driver so you can easily map your
  existing knowledge onto the Spring APIs.</para>

  <section id="cassandra-getting-started">
    <title>Getting Started</title>

    <para>Spring Data Cassandra uses the DataStax Java Driver version 2.X,
    which supports DataStax Enterprise 4/Cassandra 2.0, and Java SE 6 or
    higher. The latest commercial release (2.X as of this writing) is
    recommended. An easy way to bootstrap setting up a working environment is
    to create a Spring based project in <ulink
    url="http://spring.io/tools/sts">STS</ulink>.</para>

    <para>First you need to set up a running Cassandra server.</para>

    <para>To create a Spring project in STS go to File -&gt; New -&gt; Spring
    Template Project -&gt; Simple Spring Utility Project -&gt; press Yes when
    prompted. Then enter a project and a package name such as
    org.spring.cassandra.example.</para>

    <para>Then add the following to pom.xml dependencies section.</para>

    <programlisting lang="" language="xml">&lt;dependencies&gt;

  &lt;!-- other dependency elements omitted --&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-cassandra&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;</programlisting>

    <para>Also change the version of Spring in the pom.xml to be</para>

    <programlisting lang="" language="xml">&lt;spring.framework.version&gt;3.2.8.RELEASE&lt;/spring.framework.version&gt;</programlisting>

    <para>You will also need to add the location of the Spring Milestone
    repository for maven to your pom.xml which is at the same level of your
    &lt;dependencies/&gt; element</para>

    <programlisting language="xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-milestone&lt;/id&gt;
    &lt;name&gt;Spring Maven MILESTONE Repository&lt;/name&gt;
    &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;</programlisting>

    <para>The repository is also <ulink
    url="http://shrub.appspot.com/maven.springframework.org/milestone/org/springframework/data/">
    browseable here</ulink>.</para>

    <para>Create a simple Employee class to persist.</para>

    <para><programlisting>package org.spring.cassandra.example; 
 
import org.springframework.data.cassandra.mapping.PrimaryKey; 
import org.springframework.data.cassandra.mapping.Table; 
 
@Table 
public class Person { 
 
 @PrimaryKey 
 private String id; 
 
 private String name; 
 private int age; 
 
 public Person(String id, String name, int age) { 
  this.id = id; 
  this.name = name; 
  this.age = age; 
 } 
 
 public String getId() { 
  return id; 
 } 
 
 public String getName() { 
  return name; 
 } 
 
 public int getAge() { 
  return age; 
 } 
 
 @Override 
 public String toString() { 
  return "Person [id=" + id + ", name=" + name + ", age=" + age + "]"; 
 } 
 
}</programlisting></para>

    <para>And a main application to run</para>

    <para><programlisting>package org.spring.cassandra.example; 
 
import java.net.InetAddress; 
import java.net.UnknownHostException; 
 
import org.slf4j.Logger; 
import org.slf4j.LoggerFactory; 
import org.springframework.data.cassandra.core.CassandraOperations; 
import org.springframework.data.cassandra.core.CassandraTemplate; 
 
import com.datastax.driver.core.Cluster; 
import com.datastax.driver.core.Session; 
import com.datastax.driver.core.querybuilder.QueryBuilder; 
import com.datastax.driver.core.querybuilder.Select; 
 
public class CassandraApp { 
 
 private static final Logger LOG = LoggerFactory.getLogger(CassandraApp.class); 
 
 private static Cluster cluster; 
 private static Session session; 
 
 public static void main(String[] args) { 
 
  try { 
 
   cluster = Cluster.builder().addContactPoints(InetAddress.getLocalHost()).build(); 
 
   session = cluster.connect("mykeyspace"); 
 
   CassandraOperations cassandraOps = new CassandraTemplate(session); 
 
   cassandraOps.insert(new Person("1234567890", "David", 40)); 
 
   Select s = QueryBuilder.select().from("person"); 
   s.where(QueryBuilder.eq("id", "1234567890")); 
 
   LOG.info(cassandraOps.queryForObject(s, Person.class).getId()); 
 
   cassandraOps.truncate("person"); 
 
  } catch (UnknownHostException e) { 
   e.printStackTrace(); 
  } 
 
 } 
} 
</programlisting></para>

    <para>Even in this simple example, there are a few things to
    observe.</para>

    <itemizedlist>
      <listitem>
        <para>You can create an instance of CassandraTemplate with a Cassandra
        Session, derived from the Cluster.</para>
      </listitem>

      <listitem>
        <para>You must annotate your POJO as a Cassandra @Table, and also
        annotate the @PrimaryKey. Optionally you can override these mapping
        names to match your Cassandra database table and column names.</para>
      </listitem>

      <listitem>
        <para>You can use CQL String, or the DataStax QueryBuilder to
        construct you queries.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Examples Repository</title>

    <para>After the initial release of Spring Data Cassandra 1.0.0, we will
    start working on a showcase repository with full examples.</para>
  </section>

  <section id="cassandra-connectors">
    <title>Connecting to Cassandra with Spring</title>

    <section id="cassandra-connectors.ext_properties">
      <title>Externalize Connection Properties</title>

      <para>Create a properties file with the information you need to connect
      to Cassandra. The contact points are keyspace are the minimal required
      fields, but port is added here for clarity.</para>

      <para>We will call this cassandra.properties</para>

      <para><programlisting>cassandra.contactpoints=10.1.55.80,10.1.55.81
cassandra.port=9042
cassandra.keyspace=showcase</programlisting>We will use spring to load these
      properties into the Spring Context in the next two examples.</para>
    </section>

    <section id="cassandra-connectors.xmlconfig">
      <title>XML Configuration</title>

      <para>The XML Configuration elements for a basic Cassandra configuration
      are shown below. These elements all use default bean names to keep the
      configuration code clean and readable.</para>

      <para>While this example show how easy it is to configure Spring to
      connect to Cassandra, there are many other options. Basically, any
      option available with the DataStax Java Driver is also available in the
      Spring Data Cassandra configuration. This is including, but not limited
      to Authentication, Load Balancing Policies, Retry Policies and Pooling
      Options. All of the Spring Data Cassandra method names and XML elements
      are named exactly (or as close as possible) like the configuration
      options on the driver so mapping any existing driver configuration
      should be straight forward.</para>

      <programlisting>&lt;?xml version='1.0'?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cassandra="http://www.springframework.org/schema/data/cassandra"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/cql http://www.springframework.org/schema/cql/spring-cql-1.0.xsd
    http://www.springframework.org/schema/data/cassandra http://www.springframework.org/schema/data/cassandra/spring-cassandra-1.0.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt;

  &lt;!-- Loads the properties into the Spring Context and uses them to fill 
    in placeholders in the bean definitions --&gt;
  &lt;context:property-placeholder location="classpath:cassandra.properties" /&gt;

  &lt;!-- REQUIRED: The Cassandra Cluster --&gt;
  &lt;cassandra:cluster contact-points="${cassandra.contactpoints}"
    port="${cassandra.port}" /&gt;

  &lt;!-- REQUIRED: The Cassandra Session, built from the Cluster, and attaching 
    to a keyspace --&gt;
  &lt;cassandra:session keyspace-name="${cassandra.keyspace}" /&gt;

  &lt;!-- REQUIRED: The Default Cassandra Mapping Context used by CassandraConverter --&gt;
  &lt;cassandra:mapping /&gt;

  &lt;!-- REQUIRED: The Default Cassandra Converter used by CassandraTemplate --&gt;
  &lt;cassandra:converter /&gt;

  &lt;!-- REQUIRED: The Cassandra Template is the building block of all Spring 
    Data Cassandra --&gt;
  &lt;cassandra:template id="cassandraTemplate" /&gt;

  &lt;!-- OPTIONAL: If you are using Spring Data Cassandra Repositories, add 
    your base packages to scan here --&gt;
  &lt;cassandra:repositories base-package="org.spring.cassandra.example.repo" /&gt;

&lt;/beans&gt;
</programlisting>
    </section>

    <section id="cassandra-connectors.javaconfig">
      <title>Java Configuration</title>

      <para>The following class show a basic and minimal Cassandra
      configuration using the AnnotationConfigApplicationContext (aka
      JavaConfig).</para>

      <programlisting>package org.spring.cassandra.example.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.data.cassandra.config.CassandraClusterFactoryBean;
import org.springframework.data.cassandra.config.CassandraSessionFactoryBean;
import org.springframework.data.cassandra.config.SchemaAction;
import org.springframework.data.cassandra.convert.CassandraConverter;
import org.springframework.data.cassandra.convert.MappingCassandraConverter;
import org.springframework.data.cassandra.core.CassandraOperations;
import org.springframework.data.cassandra.core.CassandraTemplate;
import org.springframework.data.cassandra.mapping.BasicCassandraMappingContext;
import org.springframework.data.cassandra.mapping.CassandraMappingContext;
import org.springframework.data.cassandra.repository.config.EnableCassandraRepositories;

@Configuration
@PropertySource(value = { "classpath:cassandra.properties" })
@EnableCassandraRepositories(basePackages = { "org.spring.cassandra.example.repo" })
public class CassandraConfig {

  private static final Logger LOG = LoggerFactory.getLogger(CassandraConfig.class);

  @Autowired
  private Environment env;

  @Bean
  public CassandraClusterFactoryBean cluster() {

    CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean();
    cluster.setContactPoints(env.getProperty("cassandra.contactpoints"));
    cluster.setPort(Integer.parseInt(env.getProperty("cassandra.port")));

    return cluster;
  }

  @Bean
  public CassandraMappingContext mappingContext() {
    return new BasicCassandraMappingContext();
  }

  @Bean
  public CassandraConverter converter() {
    return new MappingCassandraConverter(mappingContext());
  }

  @Bean
  public CassandraSessionFactoryBean session() throws Exception {

    CassandraSessionFactoryBean session = new CassandraSessionFactoryBean();
    session.setCluster(cluster().getObject());
    session.setKeyspaceName(env.getProperty("cassandra.keyspace"));
    session.setConverter(converter());
    session.setSchemaAction(SchemaAction.NONE);

    return session;
  }

  @Bean
  public CassandraOperations cassandraTemplate() throws Exception {
    return new CassandraTemplate(session().getObject());
  }
}
</programlisting>
    </section>
  </section>

  <section id="cassandra.auditing">
    <title>General auditing configuration</title>

    <para>Auditing support is not available in the current version.</para>
  </section>

  <section id="cassandra-template">
    <title>Introduction to CassandraTemplate</title>

    <section id="cassandra-template.instantiating">
      <title>Instantiating CassandraTemplate</title>

      <para><literal>CassandraTemplate</literal> should always be configured
      as a Spring Bean, although we show an example above where you can
      instantiate it directly. But for the purposes of this being a Spring
      module, lets assume we are using the Spring Container.</para>

      <para><literal>CassandraTemplate</literal> is an implementation of
      <literal>CassandraOperations</literal>. You should always assign your
      <literal>CassandraTemplate</literal> to its interface definition,
      <literal>CassandraOperations</literal>.</para>

      <para>There are 2 easy ways to get a
      <literal>CassandraTemplate</literal>, depending on how you load you
      Spring Application Context.</para>

      <bridgehead>AutoWiring</bridgehead>

      <programlisting>@Autowired
private CassandraOperations cassandraOperations;</programlisting>

      <para>Like all Spring Autowiring, this assumes there is only one bean of
      type <literal>CassandraOperations</literal> in the
      <literal>ApplicationContext</literal>. If you have multiple
      <literal>CassandraTemplate</literal> beans (which will be the case if
      you are working with multiple keyspaces in the same project), use the
      <literal>@Qualifier </literal>annotation to designate which bean you
      want to Autowire.</para>

      <programlisting>@Autowired
@Qualifier("myTemplateBeanId")
private CassandraOperations cassandraOperations;</programlisting>

      <bridgehead>Bean Lookup with ApplicationContext</bridgehead>

      <para>You can also just lookup the <literal>CassandraTemplate</literal>
      bean from the <literal>ApplicationContext</literal>.</para>

      <programlisting>CassandraOperations cassandraOperations = applicationContext.getBean("cassandraTemplate", CassandraOperations.class);</programlisting>
    </section>
  </section>

  <section id="cassandra-template.save-update-remove">
    <title>Saving, Updating, and Removing Rows</title>

    <para><classname>CassandraTemplate</classname> provides a simple way for
    you to save, update, and delete your domain objects and map those objects
    to documents stored in Cassandra.</para>

    <section id="cassandra-template.id-handling">
      <title>How the Composite Primary Key fields are handled in the mapping
      layer</title>

      <para>Cassandra requires that you have at least 1 Partition Key field
      for a CQL Table. Alternately, you can have one or more Clustering Key
      fields. When your CQL Table has a composite Primary Key field you must
      create a @PrimaryKeyClass to define the structure of the composite PK.
      In this context, composite PK means one or more partition columns, or 1
      partition column plus one or more clustering columns.</para>

      <section>
        <title>Simplest Composite Key</title>

        <para>The simplest for of a Composite key is a key with one partition
        key and one clustering key. Here is an example of a CQL Table, and the
        corresponding POJOs that represent the table and it's composite
        key.</para>

        <para>CQL Table defined in Cassandra</para>

        <programlisting>create table login_event(
  person_id text, 
  event_time timestamp,
  event_code int,
  ip_address text,
  primary key (person_id, event_time))
  with CLUSTERING ORDER BY (event_time DESC)
;</programlisting>

        <para>Class defining the <emphasis>Composite Primary Key</emphasis>.
        <emphasis role="bold">NOTE: PrimaryKeyClass must implement
        <literal>Serializable</literal> and provide implementation of
        <literal>hashCode()</literal> and <literal>equals()</literal> just
        like the example.</emphasis></para>

        <programlisting>package org.spring.cassandra.example;

import java.io.Serializable;
import java.util.Date;

import org.springframework.cassandra.core.Ordering;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;

@PrimaryKeyClass
public class LoginEventKey implements Serializable {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "event_time", ordinal = 1, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  public String getPersonId() {
    return personId;
  }

  public void setPersonId(String personId) {
    this.personId = personId;
  }

  public Date getEventTime() {
    return eventTime;
  }

  public void setEventTime(Date eventTime) {
    this.eventTime = eventTime;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((eventTime == null) ? 0 : eventTime.hashCode());
    result = prime * result + ((personId == null) ? 0 : personId.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LoginEventKey other = (LoginEventKey) obj;
    if (eventTime == null) {
      if (other.eventTime != null)
        return false;
    } else if (!eventTime.equals(other.eventTime))
      return false;
    if (personId == null) {
      if (other.personId != null)
        return false;
    } else if (!personId.equals(other.personId))
      return false;
    return true;
  }
}
</programlisting>

        <para>Class defining the CQL Table, having the <emphasis>Composite
        Primary Key</emphasis> as an attribute and annotated as the
        <literal>PrimaryKey</literal>.</para>

        <programlisting>package org.spring.cassandra.example;

import org.springframework.data.cassandra.mapping.Column;
import org.springframework.data.cassandra.mapping.PrimaryKey;
import org.springframework.data.cassandra.mapping.Table;

@Table(value = "login_event")
public class LoginEvent {

  @PrimaryKey
  private LoginEventKey pk;

  @Column(value = "event_code")
  private int eventCode;

  @Column(value = "ip_address")
  private String ipAddress;

  public LoginEventKey getPk() {
    return pk;
  }

  public void setPk(LoginEventKey pk) {
    this.pk = pk;
  }

  public int getEventCode() {
    return eventCode;
  }

  public void setEventCode(int eventCode) {
    this.eventCode = eventCode;
  }

  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }

}
</programlisting>
      </section>

      <section>
        <title>Complex Composite Primary Key</title>

        <para>The annotations provided with Spring Data Cassandra can handle
        any key combination available in Cassandra. Here is one more example
        of a Composite Primary Key with 5 columns, 2 of which are a composite
        partition key, and the remaining 3 are ordered clustering keys. The
        getters/setters, hashCode and equals are omitted for brevity.</para>

        <programlisting>package org.spring.cassandra.example;

import java.io.Serializable;
import java.util.Date;

import org.springframework.cassandra.core.Ordering;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;

@PrimaryKeyClass
public class DetailedLoginEventKey implements Serializable {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "wks_id", ordinal = 1, type = PrimaryKeyType.PARTITIONED)
  private String workstationId;

  @PrimaryKeyColumn(ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.ASCENDING)
  private Date application;

  @PrimaryKeyColumn(name = "event_code", ordinal = 3, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.ASCENDING)
  private Date eventCode;

  @PrimaryKeyColumn(name = "event_time", ordinal = 4, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  ...

}
</programlisting>
      </section>
    </section>

    <section id="cassandra-template.type-mapping">
      <title>Type mapping</title>

      <para>Spring Data Cassandra relies on the DataStax Java Driver type
      mapping component. This approach ensures that as types are added or
      changed, the Spring Data Cassandra module will continue to function
      without requiring changes. For more information on the DataStax CQL3 to
      Java Type mappings, please see their <ulink
      url="http://www.datastax.com/documentation/developer/java-driver/2.0/java-driver/reference/javaClass2Cql3Datatypes_r.html">Documentation
      here</ulink>.</para>
    </section>

    <section id="cassandra-template.save-insert">
      <title>Methods for saving and inserting rows</title>

      <section>
        <title>Single records inserts</title>

        <para>To insert one row at a time, there are many options. At this
        point you should already have a cassandraTemplate available to you so
        we will just how the relevant code for each section, omitting the
        template setup.</para>

        <para>Insert a record with an annotated POJO.</para>

        <programlisting>cassandraOperations.insert(new Person("123123123", "Alison", 39));</programlisting>

        <para>Insert a row using the QueryBuilder.Insert object that is part
        of the DataStax Java Driver.</para>

        <programlisting>Insert insert = QueryBuilder.insertInto("person");
insert.setConsistencyLevel(ConsistencyLevel.ONE);
insert.value("id", "123123123");
insert.value("name", "Alison");
insert.value("age", 39);

cassandraOperations.execute(insert);</programlisting>

        <para>Then there is always the old fashioned way. You can write your
        own CQL statements.</para>

        <programlisting>String cql = "insert into person (id, name, age) values ('123123123', 'Alison', 39)";
   
cassandraOperations.execute(cql);</programlisting>
      </section>

      <section>
        <title>Multiple inserts for high speed ingestion</title>

        <para>CQLOperations, which is extended by CassandraOperations is a
        lower level Template that you can use for just about anything you need
        to accomplish with Cassandra. CqlOperations includes several
        overloaded methods named <literal>ingest()</literal>.</para>

        <para>Use these methods to pass a CQL String with Bind Markers, and
        your preferred flavor of data set (Object[][] and
        List&lt;List&lt;T&gt;&gt;).</para>

        <para>The ingest method takes advantage of static PreparedStatements
        that are only prepared once for performance. Each record in your data
        list is bound to the same PreparedStatement, then executed
        asynchronously for high performance.</para>

        <programlisting>    String cqlIngest = "insert into person (id, name, age) values (?, ?, ?)";

    List&lt;Object&gt; person1 = new ArrayList&lt;Object&gt;();
    person1.add("10000");
    person1.add("David");
    person1.add(40);

    List&lt;Object&gt; person2 = new ArrayList&lt;Object&gt;();
    person2.add("10001");
    person2.add("Roger");
    person2.add(65);

    List&lt;List&lt;?&gt;&gt; people = new ArrayList&lt;List&lt;?&gt;&gt;();
    people.add(person1);
    people.add(person2);

    cassandraOperations.ingest(cqlIngest, people);</programlisting>
      </section>
    </section>

    <section id="cassandra-template-update">
      <title>Updating rows in a CQL table</title>

      <para>TODO With Examples</para>
    </section>

    <section id="cassandra-template.delete">
      <title>Methods for removing rows</title>

      <para>TODO With Examples</para>
    </section>
  </section>

  <section id="cassandra.query">
    <title>Querying CQL Tables</title>

    <para>TODO With Examples</para>
  </section>

  <section id="cassandra.custom-converters">
    <title>Overriding default mapping with custom converters</title>

    <para>In order to have more fine grained control over the mapping process
    you can register Spring converters with the <classname>
    CassandraConverter</classname> implementations such as the <classname>
    MappingCassandraConverter</classname>.</para>

    <para>The <classname>MappingCassandraConverter</classname> checks to see
    if there are any Spring converters that can handle a specific class before
    attempting to map the object itself. To 'hijack' the normal mapping
    strategies of the <classname>MappingCassandraConverter</classname>,
    perhaps for increased performance or other custom mapping needs, you first
    need to create an implementation of the Spring <interfacename>
    Converter</interfacename> interface and then register it with the
    MappingConverter.</para>

    <note>
      <para>For more information on the Spring type conversion service see the
      reference docs <ulink
      url="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert">
      here</ulink>.</para>
    </note>

    <section id="cassandra.custom-converters.writer">
      <title>Saving using a registered Spring Converter</title>

      <para>TODO With Examples</para>
    </section>

    <section id="cassandra.custom-converters.reader">
      <title>Reading using a Spring Converter</title>

      <para>TODO With Examples</para>
    </section>

    <section id="cassandra.custom-converters.xml">
      <title>Registering Spring Converters with the CassandraConverter</title>

      <para>TODO With Examples</para>
    </section>

    <section id="cassandra.converter-disambiguation">
      <title>Converter disambiguation</title>

      <para>TODO With Examples</para>
    </section>
  </section>

  <section id="cassandra-template.commands">
    <title>Executing Commands</title>

    <section id="cassandra-template.commands.execution">
      <title>Methods for executing commands</title>

      <para>TODO With Examples</para>
    </section>
  </section>

  <section id="cassandra.mapping-usage.events">
    <title>Lifecycle Events</title>

    <para>TODO With Examples</para>
  </section>

  <section id="cassandra.exception">
    <title>Exception Translation</title>

    <para>The Spring framework provides exception translation for a wide
    variety of database and mapping technologies. This has traditionally been
    for JDBC and JPA. The Spring support for Cassandra extends this feature to
    the Cassandra Database by providing an implementation of the <classname>
    org.springframework.dao.support.PersistenceExceptionTranslator</classname>
    interface.</para>

    <para>The motivation behind mapping to Spring's <ulink
    url="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/dao.html#dao-exceptions">
    consistent data access exception hierarchy</ulink> is that you are then
    able to write portable and descriptive exception handling code without
    resorting to coding against Cassandra Exceptions. All of Spring's data
    access exceptions are inherited from the root <classname>
    DataAccessException</classname> class so you can be sure that you will be
    able to catch all database related exception within a single try-catch
    block.</para>
  </section>

  <section id="cassandra.executioncallback">
    <title>Execution callbacks</title>

    <para>TODO With Examples</para>
  </section>
</chapter>
